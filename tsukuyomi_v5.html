<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta http-equiv="Content-Security-Policy" content="default-src * 'unsafe-inline' 'unsafe-eval' data: blob:; frame-src https://www.youtube.com https://www.youtube-nocookie.com; img-src * data: blob:; connect-src *;">
<title>月讀 TSUKUYOMI</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Noto+Serif+JP:wght@700&family=Share+Tech+Mono&display=swap');
*{margin:0;padding:0;box-sizing:border-box;}
html,body{width:100%;height:100%;overflow:hidden;background:#000;touch-action:none;}
#c{display:block;width:100%;height:100%;position:fixed;top:0;left:0;}
#cover{position:fixed;inset:0;z-index:50;display:flex;flex-direction:column;align-items:center;justify-content:center;background:radial-gradient(ellipse at 50% 60%,#1a0535 0%,#06010f 70%);transition:opacity 1.4s;}
#cover.out{opacity:0;pointer-events:none;}
.cs{position:absolute;border-radius:50%;background:#fff;animation:tw var(--d,3s) var(--dl,0s) ease-in-out infinite;}
@keyframes tw{0%,100%{opacity:.15}50%{opacity:1}}
.cc{position:relative;z-index:2;text-align:center;display:flex;flex-direction:column;align-items:center;gap:13px;}
.cbadge{font-family:'Share Tech Mono',monospace;font-size:10px;letter-spacing:.4em;color:rgba(255,150,220,.7);border:1px solid rgba(255,100,200,.28);padding:4px 16px;border-radius:20px;}
.csub{font-family:'Share Tech Mono',monospace;font-size:11px;letter-spacing:.4em;color:rgba(180,140,255,.8);}
.cmain{font-family:'Noto Serif JP',serif;font-weight:700;font-size:clamp(50px,14vw,82px);letter-spacing:.05em;line-height:1.0;background:linear-gradient(155deg,#fff 10%,#dda0ff 40%,#ff88cc 70%,#ffdd88 100%);-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text;animation:tg 4s ease-in-out infinite;}
@keyframes tg{0%,100%{filter:drop-shadow(0 0 18px rgba(200,100,255,.5))}50%{filter:drop-shadow(0 0 42px rgba(255,120,200,.85))}}
.cjp{font-family:'Noto Serif JP',serif;font-size:12px;letter-spacing:.28em;color:rgba(255,255,255,.28);margin-top:-8px;}
.cmoon{width:74px;height:74px;animation:mf 5s ease-in-out infinite;}
@keyframes mf{0%,100%{transform:translateY(0)}50%{transform:translateY(-8px)}}
.cdesc{font-family:'Noto Serif JP',serif;font-size:12px;line-height:2;color:rgba(220,200,255,.52);max-width:260px;}
.sbtn{padding:16px 48px;border:none;border-radius:4px;background:linear-gradient(135deg,rgba(180,60,255,.32),rgba(255,80,180,.18));border:1px solid rgba(200,100,255,.5);color:#fff;font-family:'Noto Serif JP',serif;font-size:16px;letter-spacing:.25em;cursor:pointer;-webkit-tap-highlight-color:transparent;touch-action:manipulation;position:relative;overflow:hidden;}
.sbtn:active{transform:scale(.97);}
.shim{position:absolute;top:0;left:-60%;width:40%;height:100%;background:linear-gradient(90deg,transparent,rgba(255,255,255,.14),transparent);animation:sh 3s ease-in-out infinite 1s;}
@keyframes sh{0%{left:-60%}100%{left:160%}}
/* loading */
#ld{position:fixed;inset:0;z-index:60;background:#06010f;display:flex;flex-direction:column;align-items:center;justify-content:center;gap:14px;transition:opacity .7s;}
#ld.out{opacity:0;pointer-events:none;}
.lr{width:58px;height:58px;border-radius:50%;border:2px solid transparent;border-top-color:#e0b4ff;border-right-color:#ff88cc;animation:spin 1s linear infinite;}
.lt{font-family:'Share Tech Mono',monospace;font-size:11px;letter-spacing:.28em;color:#a78bfa;animation:bk 1.2s ease-in-out infinite;}
.lbw{width:170px;height:2px;background:rgba(124,58,237,.2);border-radius:1px;}
.lbar{height:100%;width:0%;border-radius:1px;background:linear-gradient(90deg,#9d4edd,#ff6eb0);transition:width .18s;}
@keyframes spin{to{transform:rotate(360deg)}}
@keyframes bk{0%,100%{opacity:.4}50%{opacity:1}}
/* hud */
#hud{position:fixed;top:0;left:0;right:0;z-index:20;padding:11px 16px;display:flex;align-items:center;justify-content:space-between;background:linear-gradient(180deg,rgba(6,1,15,.78) 0%,transparent 100%);pointer-events:none;opacity:0;transition:opacity 1s;}
#hud.on{opacity:1;}
.hl{font-family:'Share Tech Mono',monospace;font-size:12px;letter-spacing:.35em;color:rgba(255,180,255,.8);}
.hi{font-family:'Share Tech Mono',monospace;font-size:9px;color:rgba(255,180,220,.4);text-align:right;line-height:1.7;}
/* 場景標籤 */
#sl{position:fixed;bottom:145px;left:50%;transform:translateX(-50%);font-family:'Share Tech Mono',monospace;font-size:11px;letter-spacing:.28em;color:rgba(255,200,255,.9);pointer-events:none;opacity:0;transition:opacity .5s;white-space:nowrap;text-shadow:0 0 12px rgba(255,100,255,.8);z-index:20;}
#sl.on{opacity:1;}
/* 對話 */
#dlg{position:fixed;bottom:152px;left:50%;transform:translateX(-50%);z-index:40;display:none;align-items:flex-end;gap:11px;max-width:320px;width:88%;}
#dlg.on{display:flex;}
#dp{width:66px;height:66px;border-radius:50%;border:2px solid rgba(255,150,220,.55);overflow:hidden;flex-shrink:0;}
#dp canvas{width:100%;height:100%;}
#db{background:rgba(10,5,28,.9);border:1px solid rgba(255,120,200,.38);border-radius:12px 12px 12px 2px;padding:10px 13px;backdrop-filter:blur(8px);}
#dn{font-family:'Share Tech Mono',monospace;font-size:10px;letter-spacing:.18em;color:rgba(255,160,220,.8);margin-bottom:4px;}
#dt{font-family:'Noto Serif JP',serif;font-size:12px;line-height:1.8;color:rgba(240,220,255,.9);}
#dx{position:absolute;top:-13px;right:-13px;width:32px;height:32px;border-radius:50%;background:rgba(180,60,255,.9);border:2px solid rgba(255,150,220,.7);color:#fff;font-size:15px;font-weight:700;cursor:pointer;display:flex;align-items:center;justify-content:center;-webkit-tap-highlight-color:transparent;touch-action:manipulation;z-index:60;}
/* hint */
#hint{position:fixed;bottom:145px;left:50%;transform:translateX(-50%);z-index:25;font-family:'Share Tech Mono',monospace;font-size:11px;letter-spacing:.18em;color:rgba(255,200,120,.9);background:rgba(10,5,28,.7);border:1px solid rgba(255,180,80,.3);padding:5px 14px;border-radius:20px;display:none;pointer-events:none;}
/* 跳躍鍵 */
#jumpBtn{position:fixed;bottom:28px;right:18px;z-index:25;width:72px;height:72px;border-radius:50%;background:radial-gradient(circle,rgba(255,200,80,.35),rgba(200,100,0,.2));border:2px solid rgba(255,200,80,.6);color:#ffe066;font-size:22px;display:none;align-items:center;justify-content:center;-webkit-tap-highlight-color:transparent;touch-action:manipulation;box-shadow:0 0 18px rgba(255,180,0,.3);user-select:none;cursor:pointer;font-family:sans-serif;}
#jumpBtn:active{background:radial-gradient(circle,rgba(255,220,100,.6),rgba(200,120,0,.4));box-shadow:0 0 30px rgba(255,200,0,.6);}
/* 搖桿 */
#jw{position:fixed;bottom:24px;left:16px;z-index:25;width:104px;height:104px;display:none;align-items:center;justify-content:center;pointer-events:all;}
#jb{width:96px;height:96px;border-radius:50%;background:rgba(10,5,30,.52);border:1.5px solid rgba(255,100,220,.38);position:relative;}
#jk{width:34px;height:34px;border-radius:50%;background:radial-gradient(circle,rgba(255,160,220,.8),rgba(200,60,180,.5));border:1.5px solid rgba(255,160,220,.65);box-shadow:0 0 12px rgba(255,80,200,.5);position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);}

/* ── YouTube 大螢幕 UI ── */
#ytPanel{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);z-index:80;
  background:rgba(8,4,20,.95);border:1px solid rgba(255,120,60,.5);border-radius:12px;
  padding:20px;width:min(320px,88vw);display:none;flex-direction:column;gap:12px;
  backdrop-filter:blur(16px);box-shadow:0 0 40px rgba(255,80,0,.2);}
#ytPanel.on{display:flex;}
#ytPanelTitle{font-family:'Share Tech Mono',monospace;font-size:11px;letter-spacing:.3em;
  color:rgba(255,180,80,.9);text-align:center;}
#ytInput{background:rgba(255,255,255,.06);border:1px solid rgba(255,150,60,.4);border-radius:6px;
  padding:10px 12px;color:#fff;font-family:'Share Tech Mono',monospace;font-size:12px;
  outline:none;width:100%;}
#ytInput::placeholder{color:rgba(255,200,100,.35);}
.ytBtnRow{display:flex;gap:8px;}
.ytBtn{flex:1;padding:10px;border:none;border-radius:6px;cursor:pointer;
  font-family:'Noto Serif JP',serif;font-size:13px;letter-spacing:.1em;
  -webkit-tap-highlight-color:transparent;touch-action:manipulation;}
#ytPlayBtn{background:linear-gradient(135deg,rgba(255,80,0,.7),rgba(255,40,0,.5));
  border:1px solid rgba(255,120,60,.6);color:#fff;}
#ytCloseBtn{background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.2);color:rgba(255,255,255,.7);}
/* 大螢幕靠近提示 */
#screenHint{position:fixed;bottom:145px;left:50%;transform:translateX(-50%);z-index:25;
  font-family:'Share Tech Mono',monospace;font-size:11px;letter-spacing:.18em;
  color:rgba(255,180,80,.9);background:rgba(10,5,28,.7);border:1px solid rgba(255,150,60,.3);
  padding:5px 14px;border-radius:20px;display:none;pointer-events:none;}
</style>
</head>
<body>
<canvas id="c"></canvas>

<div id="cover">
  <div id="cstars"></div>
  <div class="cc">
    <div class="cbadge">VIRTUAL SPACE · 月讀計畫</div>
    <div class="csub">ツクヨミ / TSUKUYOMI</div>
    <div class="cmain">超時空<br>輝耀姬</div>
    <div class="cjp">超時空輝耀姫！</div>
    <div class="cmoon">
      <svg width="74" height="74" viewBox="0 0 74 74" fill="none">
        <circle cx="37" cy="37" r="29" fill="url(#mg)"/>
        <circle cx="49" cy="30" r="20" fill="rgba(6,1,15,.73)"/>
        <circle cx="25" cy="27" r="3" fill="rgba(255,255,255,.6)"/>
        <circle cx="32" cy="19" r="1.7" fill="rgba(224,180,255,.9)"/>
        <defs><radialGradient id="mg" cx="36%" cy="30%"><stop offset="0%" stop-color="#f5eeff"/><stop offset="50%" stop-color="#c084fc"/><stop offset="100%" stop-color="#4c1d95"/></radialGradient></defs>
      </svg>
    </div>
    <div class="cdesc">霓虹燈火的古都夜空<br>屬於彩葉與輝耀的永恆月夜</div>
    <button class="sbtn" id="sbtn"><div class="shim"></div>▶　開始遊戲</button>
  </div>
</div>

<div id="ld" class="out">
  <div class="lr"></div>
  <div class="lt">月讀空間　構築中...</div>
  <div class="lbw"><div class="lbar" id="lbar"></div></div>
</div>

<div id="hud"><div class="hl">ツクヨミ</div><div class="hi" id="hi">自由探索中</div></div>
<div id="sl"></div>

<div id="dlg">
  <div id="dp"><canvas id="dpc" width="66" height="66"></canvas></div>
  <div id="db"><div id="dn">彩葉 · AYAHA</div><div id="dt">...</div></div>
  <div id="dx">✕</div>
</div>

<!-- YouTube 面板 -->
<div id="ytPanel">
  <div id="ytPanelTitle">▶ 大螢幕　貼上 YouTube 連結</div>
  <input id="ytInput" type="text" placeholder="https://www.youtube.com/watch?v=..." autocomplete="off"/>
  <div class="ytBtnRow">
    <button class="ytBtn" id="ytPlayBtn">播放</button>
    <button class="ytBtn" id="ytCloseBtn">關閉</button>
  </div>
</div>
<div id="screenHint">▲ 點擊操作大螢幕</div>

<div id="hint">▲ 點擊與彩葉對話</div>
<div id="jw"><div id="jb"><div id="jk"></div></div></div>
<div id="jumpBtn">↑</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// ── 封面星點 ──────────────────────────────────────
(()=>{
  const w=document.getElementById('cstars');
  for(let i=0;i<90;i++){
    const s=document.createElement('div'); s.className='cs';
    const z=Math.random()*2.4+.4;
    s.style.cssText=`left:${Math.random()*100}%;top:${Math.random()*100}%;width:${z}px;height:${z}px;--d:${2+Math.random()*4}s;--dl:${Math.random()*5}s;opacity:${Math.random()*.6+.1};`;
    w.appendChild(s);
  }
})();

// ── 頭像 Canvas ───────────────────────────────────
(()=>{
  const c=document.getElementById('dpc'),x=c.getContext('2d'),S=66;
  const bg=x.createRadialGradient(33,33,0,33,33,33);
  bg.addColorStop(0,'#1a0828'); bg.addColorStop(1,'#06010f');
  x.fillStyle=bg; x.fillRect(0,0,S,S);
  x.fillStyle='#1a1a2e'; x.beginPath(); x.ellipse(33,58,17,11,0,0,Math.PI); x.fill();
  x.fillStyle='#f5c896'; x.beginPath(); x.ellipse(33,35,13,15,0,0,Math.PI*2); x.fill();
  x.fillStyle='#251030';
  x.beginPath(); x.ellipse(33,25,15,12,0,0,Math.PI*2); x.fill();
  x.beginPath(); x.ellipse(21,35,7,11,-0.25,0,Math.PI*2); x.fill();
  x.beginPath(); x.ellipse(45,35,7,11,0.25,0,Math.PI*2); x.fill();
  [[18,19,12,8,26,21],[48,19,54,8,46,21]].forEach(([bx,by,tx,ty,ex,ey])=>{
    x.fillStyle='#251030'; x.beginPath(); x.moveTo(bx,by); x.lineTo(tx,ty); x.lineTo(ex,ey); x.closePath(); x.fill();
    x.fillStyle='#c4896a'; x.beginPath(); x.moveTo(bx+1,by+1); x.lineTo(tx,ty+1); x.lineTo(ex-1,ey); x.closePath(); x.fill();
  });
  [[26,35],[40,35]].forEach(([ex,ey])=>{
    x.fillStyle='#1a2e1a'; x.beginPath(); x.ellipse(ex,ey,4.5,5.5,0,0,Math.PI*2); x.fill();
    x.fillStyle='#3a8a3a'; x.beginPath(); x.ellipse(ex,ey,3,4,0,0,Math.PI*2); x.fill();
    x.fillStyle='#0a1a0a'; x.beginPath(); x.ellipse(ex,ey,1.8,2.7,0,0,Math.PI*2); x.fill();
    x.fillStyle='rgba(255,255,255,.9)'; x.beginPath(); x.arc(ex+1,ey-1,1.1,0,Math.PI*2); x.fill();
  });
  x.fillStyle='#cc2244'; x.beginPath(); x.moveTo(33,24); x.lineTo(35.5,27); x.lineTo(33,30); x.lineTo(30.5,27); x.closePath(); x.fill();
  x.strokeStyle='#c07060'; x.lineWidth=1.2;
  x.beginPath(); x.moveTo(29,44); x.quadraticCurveTo(33,47,37,44); x.stroke();
  x.globalCompositeOperation='destination-in';
  x.beginPath(); x.arc(33,33,33,0,Math.PI*2); x.fill();
})();

// ── 對話 ─────────────────────────────────────────
const LINES=[
  '歡迎來到月讀！\n這裡是永不落幕的夜晚 ✦',
  '你看那邊！煙火又開始了 ✨',
  '月讀的霓虹比任何城市都亮\n我很喜歡這裡 ♪',
  '左邊搖桿移動，右邊滑動轉視角',
  '輝耀說這座城市永遠不會天亮\n也許這樣也不錯 ♡',
];
let dIdx=0, dOpen=false;
function openDlg(){ document.getElementById('dt').textContent=LINES[dIdx++%LINES.length]; document.getElementById('dlg').classList.add('on'); dOpen=true; }
function closeDlg(e){ if(e){e.stopPropagation();e.preventDefault();} document.getElementById('dlg').classList.remove('on'); dOpen=false; }
const dxBtn=document.getElementById('dx');
dxBtn.addEventListener('click',closeDlg);
dxBtn.addEventListener('touchend',closeDlg,{passive:false});
dxBtn.addEventListener('touchstart',e=>e.stopPropagation(),{passive:false});

// ── 開始 ─────────────────────────────────────────
document.getElementById('sbtn').addEventListener('click',()=>{
  document.getElementById('cover').classList.add('out');
  const ld=document.getElementById('ld'); ld.classList.remove('out'); ld.style.opacity='1';
  let p=0; const bar=document.getElementById('lbar');
  const iv=setInterval(()=>{
    p+=Math.random()*20+9; bar.style.width=Math.min(p,95)+'%';
    if(p>=95){ clearInterval(iv); bar.style.width='100%';
      setTimeout(()=>{
      const ldEl=document.getElementById('ld');
      ldEl.style.transition='opacity 0.5s';
      ldEl.style.opacity='0';
      setTimeout(()=>{ ldEl.style.display='none'; initGame(); }, 500);
    },300); }
  },120);
});

// ════════════════════════════════════════════════════════
//  GAME  —  目標：< 25 drawcalls
//  策略：InstancedMesh + BufferGeometryUtils.mergeBufferGeometries
// ════════════════════════════════════════════════════════
function initGame(){
  // loading 已 display:none，這個 dbg 只在 catch 時顯示
  function dbg(msg){
    console.log('[INIT]', msg);
  }
  try {
  document.getElementById('hud').classList.add('on');
  document.getElementById('jw').style.display='flex';
  const jumpBtnEl=document.getElementById('jumpBtn');
  jumpBtnEl.style.display='flex';
  jumpBtnEl.addEventListener('touchstart',e=>{
    e.stopPropagation(); e.preventDefault();
    if(onGround){ velY=JUMP_V; onGround=false; }
  },{passive:false});
  jumpBtnEl.addEventListener('click',()=>{ if(onGround){ velY=JUMP_V; onGround=false; } });
  setTimeout(openDlg, 1000);

  const renderer=new THREE.WebGLRenderer({canvas:document.getElementById('c'), antialias:false, powerPreference:'high-performance'});
  renderer.setPixelRatio(Math.min(devicePixelRatio,1.5));
  renderer.setSize(window.innerWidth,window.innerHeight);
  renderer.shadowMap.enabled=false;
  renderer.toneMapping=THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure=1.25;

  const scene=new THREE.Scene();
  dbg("1/8 scene init...");
  scene.fog=new THREE.FogExp2(0x0d0510, 0.015);

  const camera=new THREE.PerspectiveCamera(65,window.innerWidth/window.innerHeight,.1,220);
  camera.position.set(0,2.2,6);
  let T=0, lastNow=performance.now();

  // ── 天空 ─────────────────────────────────────────
  // drawcall: 1
  dbg("2/8 sky...");
  const skyMat=new THREE.ShaderMaterial({side:THREE.BackSide, uniforms:{uT:{value:0}},
    vertexShader:`varying vec3 vP;void main(){vP=position;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.);}`,
    fragmentShader:`
      varying vec3 vP; uniform float uT;
      float h(vec2 p){p=fract(p*vec2(127.1,311.7));p+=dot(p,p+19.);return fract(p.x*p.y);}
      float n(vec2 p){vec2 i=floor(p),f=fract(p),u=f*f*(3.-2.*f);return mix(mix(h(i),h(i+vec2(1,0)),u.x),mix(h(i+vec2(0,1)),h(i+vec2(1,1)),u.x),u.y);}
      void main(){
        vec3 d=normalize(vP); float t=uT*.016;
        float n1=n(d.xz*1.8+t)*.55+n(d.xz*3.8-t*.7)*.3+n(d.xy*2.8+t*.4)*.15;
        vec3 sky=mix(vec3(.02,.005,.04),vec3(.08,.02,.18),smoothstep(.2,.6,n1));
        float hz=smoothstep(-.05,.22,-d.y);
        sky=mix(sky,vec3(.35,.10,.08),hz*.8);
        sky+=vec3(.30,.10,.04)*smoothstep(0.,.12,-d.y);
        sky+=vec3(.15,.05,.02)*smoothstep(.12,.0,-d.y)*.6;
        float st=step(.997,h(floor(d.xz*360.)));
        sky+=st*vec3(.9,.9,1.);
        gl_FragColor=vec4(sky,1.);
      }`});
  scene.add(new THREE.Mesh(new THREE.SphereGeometry(200,20,10),skyMat));

  // ── 地面 ─────────────────────────────────────────
  // drawcall: 1
  dbg("3/8 ground...");
  const gnd=new THREE.Mesh(new THREE.PlaneGeometry(280,280),
    new THREE.MeshStandardMaterial({color:0x1a0c10,roughness:.25,metalness:.6}));
  gnd.rotation.x=-Math.PI/2; scene.add(gnd);

  // ── 燈光（最少化）────────────────────────────────
  // 只用 ambient + 1 directional + 2 point = 不佔 drawcall
  scene.add(new THREE.AmbientLight(0x1e0e18,1.5));
  const moon=new THREE.DirectionalLight(0xffcc88,.45); moon.position.set(20,60,-40); scene.add(moon);
  (()=>{const l=new THREE.PointLight(0xff6600,1.4,130);l.position.set(0,5,0);scene.add(l);})();
  (()=>{const l=new THREE.PointLight(0xff8844,1.0,90);l.position.set(-6,4,-15);scene.add(l);})();
  (()=>{const l=new THREE.PointLight(0xff4466,1.0,90);l.position.set(6,4,-15);scene.add(l);})();

  // ════════════════════════════════════════════════
  //  核心優化：InstancedMesh
  //  所有同類物件 → 一個 drawcall
  // ════════════════════════════════════════════════
  const M4=new THREE.Matrix4();
  const dummy=new THREE.Object3D();

  // ── 建築主體 (InstancedMesh) — 1 drawcall ────────
  dbg("4/8 buildings...");
  const BDATA=[
    // [x, z, w, h_total, d, wall_color_hue]
    // 左街
    [-8,6, 5,8.7,4],[-8,-4, 6,11.6,5],[-8,-14,5,8.7,4],[-8,-24,7,14.5,5],
    [-8,-34,5,11.6,4],[-8,-44,6,8.7,5],[-8,16, 4,5.8,3],[-8,-54,5,8.7,4],
    // 右街
    [8,6, 6,11.6,5],[8,-4, 5,8.7,4],[8,-14,7,14.5,5],[8,-24,5,11.6,4],
    [8,-34,6,8.7,5],[8,-44,5,11.6,4],[8,16, 4,5.8,3],[8,-54,6,8.7,5],
    // 中景 左
    [-18,-8,8,17.4,6],[-18,-22,7,14.5,5],[-18,-36,8,17.4,6],[-18,-50,6,11.6,4],
    // 中景 右
    [18,-8,8,17.4,6],[18,-22,7,14.5,5],[18,-36,8,17.4,6],[18,-50,6,11.6,4],
    // 遠景
    [-32,-18,10,23.2,8],[-32,-38,9,20.3,7],[32,-18,10,23.2,8],[32,-38,9,20.3,7],
    [-46,-28,12,29.0,9],[46,-28,12,29.0,9],[0,-60,14,34.8,10],
    // 超遠景（小、暗）
    [-22,-55,6,14.5,5],[22,-55,6,14.5,5],[-40,-55,8,17.4,6],[40,-55,8,17.4,6],
    [-12,-55,5,11.6,4],[12,-55,5,11.6,4],
  ];
  const bCount=BDATA.length;
  const bGeo=new THREE.BoxGeometry(1,1,1);
  const bMat=new THREE.MeshStandardMaterial({color:0x2a1408,roughness:.72,metalness:.04});
  const bInst=new THREE.InstancedMesh(bGeo,bMat,bCount);
  BDATA.forEach(([x,z,w,h,d],i)=>{
    dummy.position.set(x,h/2,z); dummy.scale.set(w,h,d); dummy.updateMatrix();
    bInst.setMatrixAt(i,dummy.matrix);
  });
  // 每棟建築設不同暖色調
  const bCol=new THREE.Color();
  const bWallPalette=[0x2a1408,0x2e180a,0x220e06,0x1e1008,0x28120a,0x241606,0x1a1010,0x2c1a0a];
  BDATA.forEach((_,i)=>{
    bCol.set(bWallPalette[i%bWallPalette.length]); bInst.setColorAt(i,bCol);
  });
  bInst.instanceColor.needsUpdate=true;
  bInst.instanceMatrix.needsUpdate=true;
  scene.add(bInst); // drawcall: 1

  // ── 屋頂（Instanced）— 1 drawcall ─────────────────
  const roofGeo=(()=>{
    const g=new THREE.BufferGeometry();
    // 簡化的四稜錐（pyramid）頂點
    const v=new Float32Array([
      -.5,0,-.5, .5,0,-.5, 0,.3,0,
       .5,0,-.5, .5,0, .5, 0,.3,0,
       .5,0, .5,-.5,0, .5, 0,.3,0,
      -.5,0, .5,-.5,0,-.5, 0,.3,0,
    ]);
    g.setAttribute('position',new THREE.BufferAttribute(v,3));
    g.computeVertexNormals(); return g;
  })();
  const roofInst=new THREE.InstancedMesh(roofGeo,
    new THREE.MeshStandardMaterial({color:0x3a0a06,roughness:.75}), bCount);
  BDATA.forEach(([x,z,w,h,d],i)=>{
    dummy.position.set(x,h,z); dummy.scale.set(w+1.1,1,d+1.1); dummy.updateMatrix();
    roofInst.setMatrixAt(i,dummy.matrix);
  });
  roofInst.instanceMatrix.needsUpdate=true;
  scene.add(roofInst); // drawcall: 1

  // ── 窗戶（Instanced，合批）— 1 drawcall ───────────
  // 每棟建築正面3層各2窗 = 6窗/棟，共約200窗
  const winPositions=[];
  BDATA.forEach(([x,z,w,h,d])=>{
    const floors=Math.round(h/2.9);
    const wc=Math.max(2,Math.floor(w/1.8));
    for(let f=0;f<Math.min(floors,4);f++){
      for(let i=0;i<wc;i++){
        winPositions.push([
          x - w/2+.9+i*(w-1.4)/Math.max(wc-1,1),
          f*2.9+1.4,
          z + d/2+.01,
          .72, .88
        ]);
      }
    }
  });
  const winInst=new THREE.InstancedMesh(
    new THREE.PlaneGeometry(1,1),
    new THREE.MeshStandardMaterial({color:0xfffce0,emissive:0xffeeaa,emissiveIntensity:3.0,transparent:true,opacity:.92}),
    winPositions.length);
  winPositions.forEach(([x,y,z,sw,sh],i)=>{
    dummy.position.set(x,y,z); dummy.rotation.set(0,0,0); dummy.scale.set(sw,sh,1); dummy.updateMatrix();
    winInst.setMatrixAt(i,dummy.matrix);
  });
  winInst.instanceMatrix.needsUpdate=true;
  scene.add(winInst); // drawcall: 1

  // ── 霓虹招牌（Instanced）— 1 drawcall ─────────────
  const signColors=[
    0xff6644,0xff9933,0xffcc44,0xff4466,0xff88aa,0xff5500,0xffaa44,0xff3366,
    0xffdd66,0xff6699,0xffbb33,0xff4488,0xffaa66,0xff7744,0xffcc88,0xff5566,
    0xff8833,0xffdd44,0xff6644,0xffaa33,0xff5544,0xff9966,0xffcc55,0xff4455,
    0xff7766,0xffbb44,0xff6633,0xffaa55,0xff8844,0xffdd55,0xff5533,
    0xff9944,0xffcc66,0xff6655,0xffaa44,0xff7733,0xffdd55,
  ];
  const signInst=new THREE.InstancedMesh(
    new THREE.BoxGeometry(1,.55,.06),
    new THREE.MeshStandardMaterial({color:0xff88cc,emissive:0xff44aa,emissiveIntensity:4.5,roughness:.1}),
    bCount);
  const signColor=new THREE.Color();
  BDATA.forEach(([x,z,w,h,d],i)=>{
    dummy.position.set(x, h*.52, z+d/2+.04); dummy.rotation.set(0,0,0);
    dummy.scale.set(w*.78, 1, 1); dummy.updateMatrix();
    signInst.setMatrixAt(i,dummy.matrix);
    signColor.set(signColors[i%signColors.length]);
    signInst.setColorAt(i,signColor);
  });
  signInst.instanceMatrix.needsUpdate=true;
  signInst.instanceColor.needsUpdate=true;
  scene.add(signInst); // drawcall: 1

  // ── 燈籠（Instanced）— 1 drawcall ────────────────
  const lanternPos=[];
  BDATA.forEach(([x,z,w,h,d],i)=>{
    if(i%2===0){
      for(let li=0;li<3;li++) lanternPos.push([x-w/2+.3+li*w*.35, h+.35, z]);
    }
  });
  const lanInst=new THREE.InstancedMesh(
    new THREE.SphereGeometry(.19,6,6),
    new THREE.MeshStandardMaterial({color:0xff5500,emissive:0xff3300,emissiveIntensity:4.0,transparent:true,opacity:.92}),
    lanternPos.length);
  lanternPos.forEach(([x,y,z],i)=>{
    dummy.position.set(x,y,z); dummy.scale.set(1,1,1); dummy.updateMatrix();
    lanInst.setMatrixAt(i,dummy.matrix);
  });
  lanInst.instanceMatrix.needsUpdate=true;
  scene.add(lanInst); // drawcall: 1

  // ── 鳥居（Instanced 柱子）— 2 drawcall ───────────
  const toriiData=[[-4,7,1,0xff44aa],[4,7,1,0x44aaff],[-5,-15,.85,0xffaa00],[5,-15,.85,0x44ffcc],[-7,-32,.7,0xff66ff],[7,-32,.7,0xffcc44]];
  const toriiPoleInst=new THREE.InstancedMesh(
    new THREE.CylinderGeometry(.13,.18,1,7),
    new THREE.MeshStandardMaterial({color:0xcc1100,roughness:.6}), toriiData.length*2);
  const toriiBeamInst=new THREE.InstancedMesh(
    new THREE.BoxGeometry(1,.22,.26),
    new THREE.MeshStandardMaterial({color:0xcc1100,roughness:.6}), toriiData.length);
  let pi=0;
  toriiData.forEach(([x,z,sc],idx)=>{
    const h=6*sc;
    [-1.1*sc,1.1*sc].forEach(dx=>{
      dummy.position.set(x+dx,h/2,z); dummy.rotation.set(0,0,0); dummy.scale.set(1,h,1); dummy.updateMatrix();
      toriiPoleInst.setMatrixAt(pi++,dummy.matrix);
    });
    dummy.position.set(x,h+.1,z); dummy.rotation.set(0,0,0); dummy.scale.set(3.2*sc,1,1); dummy.updateMatrix();
    toriiBeamInst.setMatrixAt(idx,dummy.matrix);
  });
  toriiPoleInst.instanceMatrix.needsUpdate=true;
  toriiBeamInst.instanceMatrix.needsUpdate=true;
  scene.add(toriiPoleInst); scene.add(toriiBeamInst); // drawcall: 2

  // ── 霓虹電線（LineSegments 合批）— 1 drawcall ─────
  const wirePts=[];
  [
    [-8,6,5, 8,7,-1],[-8,8,-4, 8,9,5],[-8,7,-14,8,8,-4],
    [-8,9,-24,8,10,-14],[-8,10,-34,8,11,-24],
    [-18,11,-8,18,12,-8],[-18,13,-22,18,14,-22],
    [-8,6,5,0,9,-20],[8,6,5,0,9,-20],
    [-18,11,-8,-32,14,-18],[18,11,-8,32,14,-18],
    [-8,8,-24,0,10,-20],[8,8,-24,0,10,-20],
    [-32,14,-18,0,17,-60],[32,14,-18,0,17,-60],
  ].forEach(d=>{
    wirePts.push(new THREE.Vector3(d[0],d[1],d[2]), new THREE.Vector3(d[3],d[4],d[5]));
  });
  const wireObj=new THREE.LineSegments(
    new THREE.BufferGeometry().setFromPoints(wirePts),
    new THREE.LineBasicMaterial({color:0xffeecc,transparent:true,opacity:.65}));
  scene.add(wireObj); // drawcall: 1

  // ── 幾何合併工具 ─────────────────────────────────
  function mergeGeos(geoArr){
    // 先 toNonIndexed() 展開，再逐一拼接
    const expanded = geoArr.map(g => g.index ? g.toNonIndexed() : g);
    let totalVerts = 0;
    expanded.forEach(g => { totalVerts += g.attributes.position.count; });
    const positions = new Float32Array(totalVerts * 3);
    const normals   = new Float32Array(totalVerts * 3);
    let offset = 0;
    expanded.forEach(g => {
      const pos = g.attributes.position.array;
      positions.set(pos, offset * 3);
      if(g.attributes.normal){
        normals.set(g.attributes.normal.array, offset * 3);
      }
      offset += g.attributes.position.count;
    });
    const merged = new THREE.BufferGeometry();
    merged.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    merged.setAttribute('normal',   new THREE.BufferAttribute(normals, 3));
    return merged;
  }

    // ── 五重塔（合批）── 3 drawcall ──────────────────
  // 塔身合批
  dbg("5/8 tower...");
  const towerBodies=[], towerRoofs=[];
  let ty=0;
  [{w:7,h:3.2},{w:6,h:3.0},{w:5,h:2.8},{w:4,h:2.6},{w:3,h:2.4}].forEach(({w,h})=>{
    const g=new THREE.BoxGeometry(w,h,w);
    g.translate(0,ty+h/2,-20); towerBodies.push(g);
    // 屋頂
    const rv=new Float32Array([
      -(w/2+.55),0,-(w/2+.55)+(-20), (w/2+.55),0,-(w/2+.55)+(-20), 0,.85,-20,
       (w/2+.55),0,-(w/2+.55)+(-20), (w/2+.55),0, (w/2+.55)+(-20), 0,.85,-20,
       (w/2+.55),0, (w/2+.55)+(-20), -(w/2+.55),0,(w/2+.55)+(-20), 0,.85,-20,
      -(w/2+.55),0, (w/2+.55)+(-20), -(w/2+.55),0,-(w/2+.55)+(-20),0,.85,-20,
    ]);
    // 簡化：用扁Box代替pyramid
    const rg=new THREE.BoxGeometry(w+1.1,.25,w+1.1); rg.translate(0,ty+h+.12,-20);
    towerRoofs.push(rg);
    ty+=h;
  });
  // 合并塔身
  const towerBodyMerged=mergeGeos(towerBodies);
  scene.add(new THREE.Mesh(towerBodyMerged, new THREE.MeshStandardMaterial({color:0x180a30,roughness:.6}))); // drawcall:1
  const towerRoofMerged=mergeGeos(towerRoofs);
  scene.add(new THREE.Mesh(towerRoofMerged, new THREE.MeshStandardMaterial({color:0x0d0520,roughness:.65}))); // drawcall:1

  // 塔頂光環（Instanced）— 1 drawcall
  dbg("6/8 rings...");
  const ringColors=[0xff4488,0xff8800,0xffdd00,0x44ff44,0x44aaff,0x8844ff,0xff44ff];
  const ringInst=new THREE.InstancedMesh(
    new THREE.TorusGeometry(1,.055,6,24),
    new THREE.MeshStandardMaterial({color:0xff88cc,emissive:0xff44aa,emissiveIntensity:3.8,transparent:true,opacity:.88}),
    ringColors.length);
  const ringColor=new THREE.Color();
  const ringBaseY=ty+7.8;
  ringColors.forEach((c,i)=>{
    dummy.position.set(0,ringBaseY-i*.32,-20); dummy.rotation.set(Math.PI/2,0,0); dummy.scale.set(1+i*.28,1+i*.28,1); dummy.updateMatrix();
    ringInst.setMatrixAt(i,dummy.matrix);
    ringColor.set(c); ringInst.setColorAt(i,ringColor);
  });
  ringInst.instanceMatrix.needsUpdate=true; ringInst.instanceColor.needsUpdate=true;
  scene.add(ringInst); // drawcall:1
  // 塔頂杆
  (()=>{const m=new THREE.Mesh(new THREE.CylinderGeometry(.09,.13,7,7),new THREE.MeshStandardMaterial({color:0xaaaacc,roughness:.5}));m.position.set(0,ty+3.5,-20);scene.add(m);})(); // drawcall:1

  // ── 燈柱（Instanced pole+head）— 2 drawcall ──────
  dbg("7/8 lamps...");
  const LPOS=[[-6,7],[-6,-2],[-6,-11],[-6,-20],[-6,-29],[-6,-38],[6,7],[6,-2],[6,-11],[6,-20],[6,-29],[6,-38],[-14,-6],[-14,-22],[14,-6],[14,-22]];
  const lpPoleInst=new THREE.InstancedMesh(new THREE.CylinderGeometry(.055,.1,4.2,7),
    new THREE.MeshStandardMaterial({color:0x888899,roughness:.6}), LPOS.length);
  const lpHeadInst=new THREE.InstancedMesh(new THREE.SphereGeometry(.18,8,8),
    new THREE.MeshStandardMaterial({color:0xffcc66,emissive:0xff8800,emissiveIntensity:3.5}), LPOS.length);
  const lpColor=new THREE.Color();
  LPOS.forEach(([x,z],i)=>{
    dummy.position.set(x,2.1,z); dummy.rotation.set(0,0,0); dummy.scale.set(1,1,1); dummy.updateMatrix();
    lpPoleInst.setMatrixAt(i,dummy.matrix);
    dummy.position.set(x,4.5,z); dummy.scale.set(1,1,1); dummy.updateMatrix();
    lpHeadInst.setMatrixAt(i,dummy.matrix);
    lpColor.setHSL(i/LPOS.length,.95,.6); lpHeadInst.setColorAt(i,lpColor);
  });
  lpPoleInst.instanceMatrix.needsUpdate=true;
  lpHeadInst.instanceMatrix.needsUpdate=true;
  lpHeadInst.instanceColor.needsUpdate=true;
  scene.add(lpPoleInst); scene.add(lpHeadInst); // drawcall: 2

  // 燈柱環（Instanced，每柱3環）— 1 drawcall
  const lampRingInst=new THREE.InstancedMesh(
    new THREE.TorusGeometry(.4,.02,4,12),
    new THREE.MeshStandardMaterial({color:0xffcc88,emissive:0xff8833,emissiveIntensity:2.8}),
    LPOS.length*3);
  const lampRingMetas=[];
  let lri=0;
  LPOS.forEach(([x,z],pi)=>{
    for(let ri=0;ri<3;ri++){
      dummy.position.set(x,3.8-ri*.22,z); dummy.rotation.set(Math.PI/2,0,0);
      dummy.scale.set(1+ri*.3,1+ri*.3,1); dummy.updateMatrix();
      lampRingInst.setMatrixAt(lri,dummy.matrix);
      const c2=new THREE.Color().setHSL((pi/LPOS.length+ri*.12)%1,.95,.6);
      lampRingInst.setColorAt(lri,c2);
      lampRingMetas.push({x,z,y:3.8-ri*.22,ri,pi,idx:lri}); lri++;
    }
  });
  lampRingInst.instanceMatrix.needsUpdate=true;
  lampRingInst.instanceColor.needsUpdate=true;
  scene.add(lampRingInst); // drawcall:1

  // ── 霓虹魚（Instanced + Frustum Culling）— 1 drawcall ──
  const FISH=[
    // 低層 橘粉紅主調 + 少量藍青對比
    [7,8,-6,0xff6644],[-6,10,-15,0x44ccff],[11,8,-24,0xff8833],[-13,10,-32,0xffcc44],
    [4,9,-12,0xff4466],[-9,11,-22,0xff9944],[14,10,-8,0xffaa33],[-14,9,-18,0xff6688],
    [3,8,-35,0xff5533],[-8,10,-40,0x44ddff],[16,10,-14,0xffdd55],[-16,10,-28,0xff8866],
    // 中層
    [5,15,-10,0xff7744],[-10,16,-20,0xffcc33],[12,14,-30,0xff5500],[-5,17,-38,0xff9966],
    [18,15,-15,0xffaa55],[-18,16,-25,0xff6633],[8,15,-45,0xff8844],[-8,14,-50,0x55ccff],
    [0,16,-18,0xff4455],[20,15,-35,0xffdd44],[-20,17,-12,0xff6655],[2,14,-55,0xffbb33],
    // 高層
    [0,22,-20,0xff7755],[6,23,-28,0xffee44],[-6,21,-35,0xff5544],[10,24,-15,0xff9933],
    [-10,22,-42,0xff4455],[15,20,-22,0x44aaff],[-15,23,-18,0xff8833],[3,25,-50,0xffcc44],
    // 超高
    [0,30,-40,0xff6644],[8,32,-55,0xffaa33],[-8,28,-48,0x44bbff],[12,33,-30,0xff7744],
    [-12,29,-60,0xffee55],[4,31,-65,0xff5533],[-4,34,-38,0xff9966],
  ];
  const fishInst=new THREE.InstancedMesh(
    new THREE.SphereGeometry(.42,6,5),
    new THREE.MeshStandardMaterial({color:0xff8844,emissive:0xff5500,emissiveIntensity:3.5,transparent:true,opacity:.9}),
    FISH.length);
  fishInst.frustumCulled=false; // 已手動控制可見性
  const fishCol=new THREE.Color();
  FISH.forEach(([x,y,z,col],i)=>{
    dummy.position.set(x,y,z); dummy.scale.set(2.1,.82,1); dummy.rotation.set(0,0,0); dummy.updateMatrix();
    fishInst.setMatrixAt(i,dummy.matrix);
    fishCol.set(col); fishInst.setColorAt(i,fishCol);
  });
  fishInst.instanceMatrix.needsUpdate=true; fishInst.instanceColor.needsUpdate=true;
  scene.add(fishInst); // drawcall:1

  // ── 煙火（Points）— 1 drawcall ───────────────────
  dbg("8/8 fireworks...");
  const FW=500;
  const fwP=new Float32Array(FW*3), fwC=new Float32Array(FW*3);
  for(let i=0;i<FW;i++) fwP[i*3+1]=-999;
  const fwGeo=new THREE.BufferGeometry();
  fwGeo.setAttribute('position',new THREE.BufferAttribute(fwP,3));
  fwGeo.setAttribute('color',  new THREE.BufferAttribute(fwC,3));
  scene.add(new THREE.Points(fwGeo,
    new THREE.PointsMaterial({size:.26,sizeAttenuation:true,transparent:true,opacity:.95,vertexColors:true})));
  const fwData=[];
  for(let i=0;i<FW;i++) fwData.push({a:false,x:0,y:0,z:0,vx:0,vy:0,vz:0,l:0,ml:1,r:1,g:1,b:1});
  let fwH=0, fwT=0;
  const FWSITES=[[0,18,-22],[8,16,-30],[-8,20,-15],[5,22,-40],[-5,19,-35],[12,17,-25],[-12,21,-18]];
  let fwSi=0;
  function shootFW(x,y,z){
    const hue=Math.random(), cnt=30+Math.floor(Math.random()*20);
    for(let i=0;i<cnt;i++){
      const p=fwData[fwH++%FW], theta=Math.random()*Math.PI*2, phi=Math.random()*Math.PI, sp=1.8+Math.random()*3;
      p.a=true; p.x=x; p.y=y; p.z=z; p.l=0; p.ml=.55+Math.random()*.7;
      p.vx=Math.sin(phi)*Math.cos(theta)*sp; p.vy=Math.cos(phi)*sp*.6; p.vz=Math.sin(phi)*Math.sin(theta)*sp;
      const c2=new THREE.Color().setHSL((hue+Math.random()*.25)%1,1,.7);
      p.r=c2.r; p.g=c2.g; p.b=c2.b;
    }
  }
  function updateFW(dt){
    fwT+=dt; if(fwT>1.1){ fwT=0; const s=FWSITES[fwSi++%FWSITES.length]; shootFW(s[0],s[1],s[2]); }
    const pp=fwGeo.attributes.position, cc=fwGeo.attributes.color;
    fwData.forEach((p,i)=>{
      if(!p.a){pp.array[i*3+1]=-999;return;}
      p.l+=dt; if(p.l>p.ml){p.a=false;pp.array[i*3+1]=-999;return;}
      p.x+=p.vx*dt*3; p.y+=p.vy*dt*3; p.z+=p.vz*dt*3; p.vy-=9*dt;
      pp.array[i*3]=p.x; pp.array[i*3+1]=p.y; pp.array[i*3+2]=p.z;
      const f=1-p.l/p.ml; cc.array[i*3]=p.r*f; cc.array[i*3+1]=p.g*f; cc.array[i*3+2]=p.b*f;
    });
    pp.needsUpdate=true; cc.needsUpdate=true;
  }

  // ── 彩葉角色 ─────────────────────────────────────
  dbg("9/9 character...");
  const charG=new THREE.Group(); charG.position.set(0,0,3);
  const skinM=new THREE.MeshStandardMaterial({color:0xf5c896,roughness:.8});
  const hairM=new THREE.MeshStandardMaterial({color:0x251030,roughness:.9});
  const bodyM=new THREE.MeshStandardMaterial({color:0x1a1a2e,roughness:.7});
  function addMesh(geo, mat, px, py, pz, sx, sy, sz, rx, ry, rz){
    const m=new THREE.Mesh(geo, mat);
    if(px!==undefined) m.position.set(px,py,pz);
    if(sx!==undefined) m.scale.set(sx,sy,sz);
    if(rx!==undefined) m.rotation.set(rx,ry,rz);
    charG.add(m); return m;
  }
  // 軀幹
  addMesh(new THREE.CylinderGeometry(.27,.32,1.0,8), bodyM, 0,1.0,0);
  // 腿
  addMesh(new THREE.CylinderGeometry(.1,.12,.82,7), bodyM, -0.14,.35,0);
  addMesh(new THREE.CylinderGeometry(.1,.12,.82,7), bodyM,  0.14,.35,0);
  // 頭（臉皮）
  addMesh(new THREE.SphereGeometry(.27,12,10), skinM, 0,1.73,0);
  // 頭髮
  const hairHead=addMesh(new THREE.SphereGeometry(.30,10,9), hairM, 0,1.80,0);
  hairHead.scale.set(1,.84,1);
  // 側髮
  addMesh(new THREE.BoxGeometry(.12,.68,.1), hairM, -0.28,1.53,0);
  addMesh(new THREE.BoxGeometry(.12,.68,.1), hairM,  0.28,1.53,0);
  // 貓耳左右
  (()=>{const e=new THREE.Mesh(new THREE.ConeGeometry(.09,.21,4),hairM); e.position.set(-0.21,2.08,0); e.rotation.z=-0.18; charG.add(e);})();
  (()=>{const e=new THREE.Mesh(new THREE.ConeGeometry(.09,.21,4),hairM); e.position.set( 0.21,2.08,0); e.rotation.z= 0.18; charG.add(e);})();
  // 耳內粉
  const earInM=new THREE.MeshStandardMaterial({color:0xc4896a,roughness:.9});
  (()=>{const e=new THREE.Mesh(new THREE.ConeGeometry(.055,.12,4),earInM); e.position.set(-0.21,2.08,.01); e.rotation.z=-0.18; charG.add(e);})();
  (()=>{const e=new THREE.Mesh(new THREE.ConeGeometry(.055,.12,4),earInM); e.position.set( 0.21,2.08,.01); e.rotation.z= 0.18; charG.add(e);})();
  // 眼（左右）
  const eyeM=new THREE.MeshStandardMaterial({color:0x2a6a2a,emissive:0x1a4a1a,emissiveIntensity:.6});
  addMesh(new THREE.SphereGeometry(.055,8,8), eyeM, -0.10,1.73,.26);
  addMesh(new THREE.SphereGeometry(.055,8,8), eyeM,  0.10,1.73,.26);
  // 額頭菱形
  const gemM=new THREE.MeshStandardMaterial({color:0xdd2244,emissive:0xcc1133,emissiveIntensity:2.0});
  addMesh(new THREE.OctahedronGeometry(.04), gemM, 0,1.80,.27);
  // 頸圈
  addMesh(new THREE.TorusGeometry(.12,.02,6,14), new THREE.MeshStandardMaterial({color:0x111118}), 0,1.44,0, 1,1,1, Math.PI/2,0,0);
  scene.add(charG);

  // ══════════════════════════════════════════════════
  //  特色建築 + 大螢幕
  // ══════════════════════════════════════════════════

  // ── 工具：快速加 Mesh ─────────────────────────────
  function addObj(geo, mat, px,py,pz, sx,sy,sz, rx,ry,rz){
    const m=new THREE.Mesh(geo,mat);
    m.position.set(px,py,pz);
    if(sx!==undefined) m.scale.set(sx,sy,sz);
    if(rx!==undefined) m.rotation.set(rx,ry,rz);
    scene.add(m); return m;
  }
  function emMat(col,ei=3.5){ return new THREE.MeshStandardMaterial({color:col,emissive:col,emissiveIntensity:ei,roughness:.1}); }

  // ── 1. 大型牌坊（入口正面）─────────────────────────
  (()=>{
    const pm=new THREE.MeshStandardMaterial({color:0xcc2200,emissive:0x550800,emissiveIntensity:.5,roughness:.5});
    // 四根柱
    [[-3,0,8],[3,0,8],[-3,0,11],[3,0,11]].forEach(([x,y,z])=>{
      addObj(new THREE.CylinderGeometry(.22,.28,7,8),pm, x,3.5,z);
    });
    // 橫樑
    addObj(new THREE.BoxGeometry(7.5,.4,.35),pm, 0,7.2,8);
    addObj(new THREE.BoxGeometry(7.5,.4,.35),pm, 0,7.2,11);
    addObj(new THREE.BoxGeometry(7.5,.3,.3),pm, 0,6.4,8);
    // 屋簷
    addObj(new THREE.BoxGeometry(8.2,.15,.6),new THREE.MeshStandardMaterial({color:0x3a0a06,roughness:.7}), 0,7.6,9.5);
    // 霓虹裝飾
    addObj(new THREE.BoxGeometry(6.8,.08,.06),emMat(0xff6633), 0,7.35,7.98);
    addObj(new THREE.BoxGeometry(6.8,.08,.06),emMat(0xffcc44), 0,6.55,7.98);
  })();

  // ── 2. 神社本殿（右側）──────────────────────────────
  (()=>{
    const wm=new THREE.MeshStandardMaterial({color:0x2a1006,roughness:.7});
    const rm=new THREE.MeshStandardMaterial({color:0x4a0a04,roughness:.65});
    // 石階
    [[0,.25,0],[0,.55,0],[0,.85,0]].forEach(([x,y,z],i)=>{
      addObj(new THREE.BoxGeometry(9-i*1.2,.35,7-i*.8),wm, 16,y,-35);
    });
    // 主殿
    addObj(new THREE.BoxGeometry(7,5.5,5.5),wm, 16,3.75,-35);
    // 屋頂（多層）
    addObj(new THREE.BoxGeometry(8.2,.22,6.6),rm, 16,6.5,-35);
    addObj(new THREE.BoxGeometry(6.5,.22,5.2),rm, 16,7.8,-35);
    addObj(new THREE.BoxGeometry(4.5,.22,3.8),rm, 16,9.0,-35);
    // 千木（屋頂交叉裝飾）
    const km=new THREE.MeshStandardMaterial({color:0xddddcc,roughness:.5});
    addObj(new THREE.BoxGeometry(.12,.12,1.8),km, 16,9.4,-35, 1,1,1, .4,0,0);
    addObj(new THREE.BoxGeometry(.12,.12,1.8),km, 16,9.4,-35, 1,1,1, -.4,0,0);
    // 鳥居
    addObj(new THREE.CylinderGeometry(.14,.18,5.5,8),new THREE.MeshStandardMaterial({color:0xdd1100,roughness:.55}), 13.5,2.75,-29);
    addObj(new THREE.CylinderGeometry(.14,.18,5.5,8),new THREE.MeshStandardMaterial({color:0xdd1100,roughness:.55}), 18.5,2.75,-29);
    addObj(new THREE.BoxGeometry(6,.25,.25),new THREE.MeshStandardMaterial({color:0xdd1100,roughness:.55}), 16,5.6,-29);
    // 燈光
    const sl=new THREE.PointLight(0xff6622,2.0,20); sl.position.set(16,5,-33); scene.add(sl);
    // 霓虹
    addObj(new THREE.BoxGeometry(5.5,.07,.07),emMat(0xff8833), 16,6.6,-34.97);
    addObj(new THREE.BoxGeometry(5.5,.07,.07),emMat(0xffcc44), 16,7.9,-34.97);
  })();

  // ── 3. 圓形劇場（廣場左側）──────────────────────────
  (()=>{
    const stages=8;
    for(let i=0;i<stages;i++){
      const ang=i/stages*Math.PI*2;
      const r=6, x=-22+Math.cos(ang)*r, z=-8+Math.sin(ang)*r;
      addObj(new THREE.CylinderGeometry(.2,.25,5,7),
        new THREE.MeshStandardMaterial({color:0x331100,roughness:.6}), x,2.5,z);
      addObj(new THREE.SphereGeometry(.2,8,8),emMat(new THREE.Color().setHSL(i/stages,.9,.55).getHex()), x,5.2,z);
    }
    // 中央舞台
    addObj(new THREE.CylinderGeometry(2.5,.5,1,24),
      new THREE.MeshStandardMaterial({color:0x1a0808,roughness:.4,metalness:.6}), -22,.5,-8);
    addObj(new THREE.CylinderGeometry(2.2,.2,.12,24),emMat(0xff6633,.8), -22,1.08,-8);
    const sl2=new THREE.PointLight(0xff8844,3.5,18); sl2.position.set(-22,3,-8); scene.add(sl2);
  })();

  // ── 4. 商店街拱廊（中央街道上方）────────────────────
  (()=>{
    const am=new THREE.MeshStandardMaterial({color:0x220a04,roughness:.7});
    // 拱柱
    for(let z=-2;z>=-40;z-=8){
      addObj(new THREE.CylinderGeometry(.12,.16,5,7),am, -5.5,2.5,z);
      addObj(new THREE.CylinderGeometry(.12,.16,5,7),am,  5.5,2.5,z);
      // 橫拱
      addObj(new THREE.BoxGeometry(12,.12,.12),emMat(0xffeecc,.5), 0,5.1,z);
    }
    // 燈串（垂墜彩燈）
    const lanM=new THREE.MeshStandardMaterial({color:0xff4400,emissive:0xff2200,emissiveIntensity:3.5,transparent:true,opacity:.9});
    for(let z=-2;z>=-40;z-=2){
      const sway=Math.sin(z*.7)*.4;
      addObj(new THREE.SphereGeometry(.12,6,6),lanM, sway,4.2+Math.sin(z*.5)*.3,z);
    }
  })();

  // ── 5. 佛塔（左前方）────────────────────────────────
  (()=>{
    const bm=new THREE.MeshStandardMaterial({color:0x1e0c04,roughness:.65});
    const gm=new THREE.MeshStandardMaterial({color:0xaa8833,roughness:.4,metalness:.5});
    let by=0;
    [5,4.2,3.5,2.8,2.2].forEach((w,i)=>{
      const h=1.8;
      addObj(new THREE.CylinderGeometry(w/2*.9,w/2,h,8),bm, -20,by+h/2,-50);
      // 金色屋緣
      addObj(new THREE.TorusGeometry(w/2+.1,.08,5,20),gm, -20,by+h,-50, 1,1,1, Math.PI/2,0,0);
      by+=h;
    });
    // 寶珠
    addObj(new THREE.SphereGeometry(.4,10,10),gm, -20,by+.5,-50);
    addObj(new THREE.CylinderGeometry(.04,.04,2.5,6),gm, -20,by+1.8,-50);
    const bl=new THREE.PointLight(0xffcc44,2.5,22); bl.position.set(-20,5,-50); scene.add(bl);
  })();

  // ── 6. 風車（右後方，旋轉）──────────────────────────
  const windmillBlades=[];
  (()=>{
    const pm2=new THREE.MeshStandardMaterial({color:0xcc9944,roughness:.6});
    const em2=emMat(0xffcc44,2);
    addObj(new THREE.CylinderGeometry(.2,.3,8,8),pm2, 22,4,-45);
    // 葉片
    for(let i=0;i<4;i++){
      const blade=new THREE.Mesh(new THREE.BoxGeometry(.15,2.2,.06),pm2);
      blade.position.set(22,9,-45);
      const pivot=new THREE.Group();
      pivot.position.set(22,9,-45);
      const inner=new THREE.Mesh(new THREE.BoxGeometry(.15,2.2,.06),pm2);
      const ang=i/4*Math.PI*2;
      inner.position.set(Math.cos(ang)*1.1,Math.sin(ang)*1.1,0);
      inner.rotation.z=ang;
      pivot.add(inner);
      scene.add(pivot);
      windmillBlades.push(pivot);
    }
    addObj(new THREE.SphereGeometry(.3,8,8),em2, 22,9,-45);
  })();

  // ══════════════════════════════════════════════════
  //  大螢幕（YouTube 播放牆）
  //  位置：廣場正前方 (0, 5, -14)
  //  做法：3D Mesh 框架 + CSS3DRenderer overlay
  // ══════════════════════════════════════════════════

  // 螢幕 3D 框架
  const screenW=8, screenH=4.5, screenZ=-14;
  const screenFrame=new THREE.Group();
  screenFrame.position.set(0, 5.5, screenZ);
  // 外框
  const frameMat=new THREE.MeshStandardMaterial({color:0x111118,roughness:.3,metalness:.8});
  addObj(new THREE.BoxGeometry(screenW+.4, screenH+.4, .22), frameMat, 0,5.5,screenZ);
  // 霓虹框邊
  const neonFrameMat=emMat(0xff6633,4);
  [[screenW/2+.22,.0],[-(screenW/2+.22),.0]].forEach(([x])=>{
    addObj(new THREE.BoxGeometry(.12,screenH+.4,.1),neonFrameMat, x,5.5,screenZ);
  });
  [[.0,screenH/2+.22],[.0,-(screenH/2+.22)]].forEach(([,y])=>{
    addObj(new THREE.BoxGeometry(screenW+.6,.1,.1),neonFrameMat, 0,5.5+y,screenZ);
  });
  // 螢幕面板（暗色，用於無影片時）
  const screenMesh=addObj(new THREE.BoxGeometry(screenW,screenH,.05),
    new THREE.MeshStandardMaterial({color:0x0a0a14,emissive:0x111122,emissiveIntensity:1}),
    0,5.5,screenZ-.1);
  // 支柱
  addObj(new THREE.CylinderGeometry(.18,.25,5.3,8),frameMat, 0,2.75,screenZ);
  // 螢幕光暈
  const screenGlow=new THREE.PointLight(0xff8844,0,25); screenGlow.position.set(0,5.5,screenZ+1); scene.add(screenGlow);

  // CSS3D 實作 YouTube iframe（Overlay 方式）
  // 用 HTML div 疊在 3D 螢幕位置上
  const ytOverlay=document.createElement('div');
  ytOverlay.id='ytOverlay';
  ytOverlay.style.cssText='position:fixed;z-index:15;display:none;pointer-events:all;overflow:hidden;border-radius:0px;transform-origin:center center;transition:opacity 0.1s;';
  document.body.appendChild(ytOverlay);
  let ytIframe=null, ytVideoId='', screenNear=false;
  // 備用播放來源列表，依序嘗試
  const YT_SOURCES=[
    id=>`https://www.youtube-nocookie.com/embed/${id}?autoplay=1&rel=0&playsinline=1`,
    id=>`https://www.youtube.com/embed/${id}?autoplay=1&rel=0&playsinline=1`,
    id=>`https://piped.video/embed/${id}?autoplay=1`,
    id=>`https://invidious.nikkosphere.com/embed/${id}?autoplay=1`,
    id=>`https://yewtu.be/embed/${id}?autoplay=1`,
  ];
  let ytSrcIdx=0;

  function extractYtId(url){
    const m=url.match(/(?:v=|youtu\.be\/|embed\/)([\w-]{11})/);
    return m?m[1]:null;
  }

  function tryNextSource(videoId){
    if(ytSrcIdx>=YT_SOURCES.length){ showYtFallback(videoId); return; }
    const src=YT_SOURCES[ytSrcIdx++](videoId);
    if(ytIframe) ytIframe.src=src;
  }

  // 監聽 YouTube 錯誤訊息
  window.addEventListener('message',e=>{
    if(!ytVideoId) return;
    try{
      const d=typeof e.data==='string'?JSON.parse(e.data):e.data;
      // YT playerError (info: 153 or 2/5/100/101/150)
      if(d && d.event==='onError'){
        console.log('[YT] error',d.info,'→ try next source');
        tryNextSource(ytVideoId);
      }
    }catch(_){}
  });

  function playYt(videoId){
    ytVideoId=videoId;
    ytSrcIdx=0;
    ytOverlay.innerHTML='';

    // 縮圖底圖
    const thumb=document.createElement('img');
    thumb.src='https://img.youtube.com/vi/'+videoId+'/hqdefault.jpg';
    thumb.style.cssText='width:100%;height:100%;object-fit:cover;display:block;position:absolute;top:0;left:0;';
    ytOverlay.appendChild(thumb);

    // iframe
    ytIframe=document.createElement('iframe');
    ytIframe.style.cssText='position:absolute;top:0;left:0;width:100%;height:100%;border:none;background:transparent;';
    ytIframe.setAttribute('allow','autoplay; encrypted-media; picture-in-picture; fullscreen');
    ytIframe.setAttribute('allowfullscreen','');
    // 不加 sandbox，讓 YouTube 自己的 JS 能執行
    ytIframe.src=YT_SOURCES[ytSrcIdx++](videoId);

    // iframe 載入失敗時換下一個來源
    ytIframe.addEventListener('load',()=>{
      // 注入錯誤偵測：在 iframe load 後等一秒看有沒有 error
      // （因為 153 是播放時才會出現，不是 HTTP 層錯誤）
    });

    // 設一個計時器：若3秒後縮圖還在最上層，嘗試下一個來源
    let srcCheckCount=0;
    const srcCheck=setInterval(()=>{
      srcCheckCount++;
      if(!ytIframe||!ytIframe.parentNode){ clearInterval(srcCheck); return; }
      if(srcCheckCount>=3){
        clearInterval(srcCheck);
        // 嘗試下一個備用來源
        if(ytSrcIdx<YT_SOURCES.length){
          console.log('[YT] timeout, try source',ytSrcIdx);
          ytIframe.src=YT_SOURCES[ytSrcIdx++](videoId);
        } else {
          showYtFallback(videoId);
        }
      }
    },3000);

    ytOverlay.appendChild(ytIframe);
    ytOverlay.style.display='block';
    screenMesh.material.emissiveIntensity=0;
    screenGlow.intensity=3.5;
    updateScreenOverlay();
  }

  function showYtFallback(videoId){
    if(ytIframe && ytIframe.parentNode) ytIframe.parentNode.removeChild(ytIframe);
    ytIframe=null;
    // 移除舊的 fallback
    ytOverlay.querySelectorAll('.yt-fallback').forEach(e=>e.remove());
    const overlay2=document.createElement('div');
    overlay2.className='yt-fallback';
    overlay2.style.cssText='position:absolute;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;background:rgba(0,0,0,.6);cursor:pointer;';
    overlay2.innerHTML=`
      <div style="width:54px;height:38px;background:#f00;border-radius:8px;display:flex;align-items:center;justify-content:center;margin-bottom:10px;">
        <div style="border-left:18px solid #fff;border-top:11px solid transparent;border-bottom:11px solid transparent;margin-left:5px;"></div>
      </div>
      <div style="color:#fff;font-family:'Share Tech Mono',monospace;font-size:10px;text-align:center;letter-spacing:.08em;line-height:1.8;">影片無法嵌入<br>點擊開啟 YouTube</div>`;
    overlay2.addEventListener('click',()=>{
      window.open('https://www.youtube.com/watch?v='+videoId,'_blank');
    });
    overlay2.addEventListener('touchend',e=>{ e.preventDefault(); window.open('https://www.youtube.com/watch?v='+videoId,'_blank'); });
    ytOverlay.appendChild(overlay2);
  }

  function stopYt(){
    if(ytIframe){ ytOverlay.style.display='none'; }
    screenMesh.material.emissiveIntensity=1;
    screenGlow.intensity=0;
  }

  // 螢幕 overlay 位置同步：把3D螢幕四角投影到畫面座標，用CSS matrix3d貼合
  function projectPoint(wx, wy, wz){
    const v=new THREE.Vector3(wx,wy,wz);
    v.project(camera);
    return {
      x:(v.x+1)*window.innerWidth/2,
      y:(-v.y+1)*window.innerHeight/2,
      behind: v.z>1
    };
  }

  // 計算讓矩形(0,0,W,H)對齊四個目標點的CSS matrix3d
  function computeMatrix3d(tl, tr, bl, br, W, H){
    // 用一般的projective transform計算
    // 參考：https://franklinta.com/2014/09/08/mapping-css-transforms/
    function adj(m){ // 3x3 adjugate
      return [
        m[4]*m[8]-m[5]*m[7], m[2]*m[7]-m[1]*m[8], m[1]*m[5]-m[2]*m[4],
        m[5]*m[6]-m[3]*m[8], m[0]*m[8]-m[2]*m[6], m[2]*m[3]-m[0]*m[5],
        m[3]*m[7]-m[4]*m[6], m[1]*m[6]-m[0]*m[7], m[0]*m[4]-m[1]*m[3]
      ];
    }
    function multmm(a,b){
      const c=new Array(9).fill(0);
      for(let i=0;i<3;i++) for(let j=0;j<3;j++) for(let k=0;k<3;k++) c[3*i+j]+=a[3*i+k]*b[3*k+j];
      return c;
    }
    function multmv(m,v){ return [m[0]*v[0]+m[1]*v[1]+m[2]*v[2], m[3]*v[0]+m[4]*v[1]+m[5]*v[2], m[6]*v[0]+m[7]*v[1]+m[8]*v[2]]; }
    function basisToPoints(p1,p2,p3,p4){
      const m=[p1[0],p2[0],p3[0], p1[1],p2[1],p3[1], 1,1,1];
      const v=multmv(adj(m),[p4[0],p4[1],1]);
      return multmm(m,[v[0],0,0, 0,v[1],0, 0,0,v[2]]);
    }
    const src=basisToPoints([0,0],[W,0],[0,H],[W,H]);
    const dst=basisToPoints([tl.x,tl.y],[tr.x,tr.y],[bl.x,bl.y],[br.x,br.y]);
    const t=multmm(dst,adj(src));
    // 正規化
    for(let i=0;i<9;i++) t[i]/=t[8];
    return [
      t[0],t[3],0,t[6],
      t[1],t[4],0,t[7],
      0,   0,   1,0,
      t[2],t[5],0,1
    ];
  }

  const OW=480, OH=270; // iframe 原始尺寸

  function updateScreenOverlay(){
    const hw=screenW/2, hh=screenH/2;
    const sz=screenZ;
    const tl=projectPoint(-hw, 5.5+hh, sz);
    const tr=projectPoint( hw, 5.5+hh, sz);
    const bl=projectPoint(-hw, 5.5-hh, sz);
    const br=projectPoint( hw, 5.5-hh, sz);

    if(tl.behind||tr.behind||bl.behind||br.behind){
      ytOverlay.style.opacity='0'; return;
    }
    ytOverlay.style.opacity='1';

    // 設iframe固定大小，用matrix3d做透視扭曲貼合
    ytOverlay.style.width=OW+'px';
    ytOverlay.style.height=OH+'px';
    ytOverlay.style.left='0px';
    ytOverlay.style.top='0px';

    const m=computeMatrix3d(tl,tr,bl,br,OW,OH);
    ytOverlay.style.transform=`matrix3d(${m.join(',')})`;
    ytOverlay.style.transformOrigin='0 0';
  }

  // YouTube 面板控制
  document.getElementById('ytPlayBtn').addEventListener('click',()=>{
    const url=document.getElementById('ytInput').value.trim();
    const vid=extractYtId(url);
    if(vid){ playYt(vid); document.getElementById('ytPanel').classList.remove('on'); }
    else{ document.getElementById('ytInput').style.borderColor='rgba(255,80,80,.8)'; }
  });
  document.getElementById('ytCloseBtn').addEventListener('click',()=>{
    document.getElementById('ytPanel').classList.remove('on');
  });
  document.getElementById('ytInput').addEventListener('input',()=>{
    document.getElementById('ytInput').style.borderColor='rgba(255,150,60,.4)';
  });
  document.getElementById('ytInput').addEventListener('touchstart',e=>e.stopPropagation(),{passive:true});

  // 螢幕靠近互動
  window.addEventListener('click',e=>{
    if(screenNear && e.clientX>window.innerWidth*.2 && e.clientX<window.innerWidth*.8
       && e.clientY>window.innerHeight*.2 && e.clientY<window.innerHeight*.8){
      if(!dOpen) document.getElementById('ytPanel').classList.toggle('on');
    }
  });
  const screenHintEl=document.getElementById('screenHint');


  // ── 觸控系統 ─────────────────────────────────────
  const MR=36;
  const jk=document.getElementById('jk');
  const joy={a:false,id:-1,cx:0,cy:0,dx:0,dy:0};
  const look={yaw:Math.PI,pitch:.08,id:-1,lx:0,ly:0};
  function isLeft(t){return t.clientX<window.innerWidth*.48;}
  function setKnob(){jk.style.transform=`translate(calc(-50% + ${joy.dx*MR}px),calc(-50% + ${joy.dy*MR}px))`;}
  function resetJoy(){joy.a=false;joy.id=-1;joy.dx=0;joy.dy=0;jk.style.transform='translate(-50%,-50%)';}
  window.addEventListener('touchstart',e=>{
    for(const t of e.changedTouches){
      if(isLeft(t)&&!joy.a){
        joy.a=true;joy.id=t.identifier;
        const r=document.getElementById('jb').getBoundingClientRect();
        joy.cx=r.left+r.width/2;joy.cy=r.top+r.height/2;
      } else if(!isLeft(t)&&look.id===-1){look.id=t.identifier;look.lx=t.clientX;look.ly=t.clientY;}
    }
  },{passive:true});
  window.addEventListener('touchmove',e=>{
    e.preventDefault();
    for(const t of e.changedTouches){
      if(t.identifier===joy.id&&joy.a){
        const dx=t.clientX-joy.cx,dy=t.clientY-joy.cy,dist=Math.sqrt(dx*dx+dy*dy),ratio=Math.min(dist,MR)/MR,ang=Math.atan2(dy,dx);
        joy.dx=Math.cos(ang)*ratio;joy.dy=Math.sin(ang)*ratio;setKnob();
      }
      if(t.identifier===look.id){
        look.yaw-=(t.clientX-look.lx)*.0042; look.pitch-=(t.clientY-look.ly)*.003;
        look.pitch=Math.max(-.5,Math.min(.6,look.pitch)); look.lx=t.clientX;look.ly=t.clientY;
      }
    }
  },{passive:false});
  function onEnd(e){for(const t of e.changedTouches){if(t.identifier===joy.id)resetJoy();if(t.identifier===look.id)look.id=-1;}}
  window.addEventListener('touchend',onEnd,{passive:true});
  window.addEventListener('touchcancel',onEnd,{passive:true});
  let ml=false;
  window.addEventListener('mousedown',e=>{if(e.clientX>window.innerWidth/2){ml=true;look.lx=e.clientX;look.ly=e.clientY;}});
  window.addEventListener('mousemove',e=>{if(!ml||!e.buttons)return;look.yaw-=e.movementX*.003;look.pitch-=e.movementY*.003;look.pitch=Math.max(-.5,Math.min(.6,look.pitch));});
  window.addEventListener('mouseup',()=>ml=false);
  const keys={};
  window.addEventListener('keydown',e=>{
    keys[e.key]=true;
    if(e.key===' '&&onGround){ velY=JUMP_V; onGround=false; }
  });
  window.addEventListener('keyup',e=>keys[e.key]=false);
  window.addEventListener('click',e=>{
    if(!dOpen&&nearChar&&e.clientX>window.innerWidth*.25&&e.clientX<window.innerWidth*.75&&e.clientY>window.innerHeight*.25&&e.clientY<window.innerHeight*.75) openDlg();
  });

  // ── 場景標籤 ─────────────────────────────────────
  const ZONES=[{t:'— 大牌坊 —',x:0,z:9,r:6},{t:'— 大螢幕廣場 —',x:0,z:-14,r:8},{t:'— 月讀大街 —',x:0,z:-8,r:7},{t:'— 圓形劇場 —',x:-22,z:-8,r:7},{t:'— 神社本殿 —',x:16,z:-35,r:8},{t:'— 商店拱廊 —',x:0,z:-20,r:8},{t:'— 五重塔前 —',x:0,z:-20,r:6},{t:'— 佛塔廣場 —',x:-20,z:-50,r:8},{t:'— 彩葉身邊 —',x:0,z:3,r:5}];
  let lastZ='',zT=0,nearChar=false;
  const slEl=document.getElementById('sl'),hintEl=document.getElementById('hint');

  // ── 主循環 ───────────────────────────────────────
  const SPEED=.1, fwd=new THREE.Vector3(), rgt=new THREE.Vector3();
  const GRAVITY=-18, CAM_H=2.2, JUMP_V=7.5;
  let velY=0, onGround=true;
  function animate(now){
    requestAnimationFrame(animate);
    const dt=Math.min((now-lastNow)/1000,.05); lastNow=now; T+=dt;
    if(T<.1){ const ldEl=document.getElementById('ld'); if(ldEl) ldEl.style.display='none'; }
    if(T<.2){ document.getElementById('ld').style.display='none'; }
    skyMat.uniforms.uT.value=T;
    updateFW(dt);

    // 移動
    let mx=joy.dx, mz=joy.dy;
    if(keys['w']||keys['ArrowUp'])   mz=-1;
    if(keys['s']||keys['ArrowDown']) mz= 1;
    if(keys['a']||keys['ArrowLeft']) mx=-1;
    if(keys['d']||keys['ArrowRight'])mx= 1;
    const spd=SPEED*Math.min(dt*60,2);
    fwd.set(-Math.sin(look.yaw),0,-Math.cos(look.yaw));
    rgt.set( Math.cos(look.yaw),0,-Math.sin(look.yaw));
    camera.position.addScaledVector(fwd,-mz*spd);
    camera.position.addScaledVector(rgt, mx*spd);
    // 跳躍物理
    velY += GRAVITY * dt;
    camera.position.y += velY * dt;
    if(camera.position.y <= CAM_H){ camera.position.y=CAM_H; velY=0; onGround=true; }
    else { onGround=false; }
    camera.rotation.order='YXZ'; camera.rotation.y=look.yaw; camera.rotation.x=look.pitch;

    // 標籤
    const px=camera.position.x,pz=camera.position.z;
    for(const z of ZONES){
      if(Math.sqrt((px-z.x)**2+(pz-z.z)**2)<z.r&&z.t!==lastZ){lastZ=z.t;slEl.textContent=z.t;slEl.classList.add('on');zT=2.5;}
    }
    if(zT>0){zT-=dt;if(zT<=0)slEl.classList.remove('on');}

    // 彩葉互動
    nearChar=Math.sqrt(px*px+(pz-3)**2)<4.5;
    hintEl.style.display=nearChar&&!dOpen?'block':'none';

    // 彩葉面向玩家
    charG.lookAt(camera.position.x,0,camera.position.z);
    charG.position.y=Math.sin(T*.7)*.07;

    // 塔環旋轉（更新 instanceMatrix）
    ringColors.forEach((c,i)=>{
      dummy.position.set(0,ringBaseY-i*.32,-20);
      dummy.rotation.set(Math.PI/2, T*(.5+i*.18), 0);
      dummy.scale.set(1+i*.28,1+i*.28,1); dummy.updateMatrix();
      ringInst.setMatrixAt(i,dummy.matrix);
    });
    ringInst.instanceMatrix.needsUpdate=true;

    // 燈柱環旋轉
    lampRingMetas.forEach(({x,z,y,ri,pi,idx})=>{
      dummy.position.set(x,y,z);
      dummy.rotation.set(Math.PI/2, T*(.55+ri*.22)+pi, 0);
      dummy.scale.set(1+ri*.3,1+ri*.3,1); dummy.updateMatrix();
      lampRingInst.setMatrixAt(idx,dummy.matrix);
    });
    lampRingInst.instanceMatrix.needsUpdate=true;

    // 霓虹線閃爍（shader uniform 更省，這裡改opacity）
    wireObj.material.opacity=.5+.35*Math.sin(T*2.5);

    // 魚飛翔動畫 + 視野距離剔除
    let fishDirty=false;
    FISH.forEach(([x,y,z,col],i)=>{
      const spd2=0.18+i*0.015;
      const nx=x + Math.sin(T*spd2+i*2.1)*3.5;
      const ny=y + Math.sin(T*(spd2*.7)+i*1.3)*1.8;
      const nz=z + Math.cos(T*spd2*0.6+i*0.8)*2.5;
      // 視野距離剔除：超過 75 單位縮成 0 不渲染
      const dx2=nx-camera.position.x, dz2=nz-camera.position.z;
      const dist2=dx2*dx2+dz2*dz2;
      if(dist2>75*75){
        dummy.scale.set(0,0,0); dummy.updateMatrix();
        fishInst.setMatrixAt(i,dummy.matrix); fishDirty=true; return;
      }
      const yaw=Math.atan2(
        Math.cos(T*spd2+i*2.1)*spd2,
        -Math.sin(T*spd2*0.6+i*0.8)*spd2*0.6
      );
      const tilt=Math.sin(T*(spd2*.7)+i*1.3)*0.22;
      dummy.position.set(nx,ny,nz);
      dummy.rotation.set(tilt, yaw, Math.sin(T*spd2*1.2+i)*.1);
      dummy.scale.set(2.2+Math.sin(T*spd2*2+i)*.12, .82, 1);
      dummy.updateMatrix();
      fishInst.setMatrixAt(i,dummy.matrix); fishDirty=true;
    });
    if(fishDirty) fishInst.instanceMatrix.needsUpdate=true;

    document.getElementById('hi').textContent=`(${px.toFixed(0)}, ${(-pz).toFixed(0)})`;

    // 風車旋轉
    windmillBlades.forEach(b=>{ b.rotation.z=T*.8; });

    // 螢幕光暈呼吸
    if(ytIframe && ytOverlay.style.display!=='none'){
      screenGlow.intensity=3.0+Math.sin(T*2)*.5;
    }
    // 每幀都更新螢幕overlay位置
    if(ytIframe && ytOverlay.style.display!=='none'){
      updateScreenOverlay();
    }

    // 螢幕靠近偵測
    const sdx=px, sdz=pz-screenZ;
    screenNear=Math.sqrt(sdx*sdx+sdz*sdz)<8;
    screenHintEl.style.display=screenNear&&!dOpen&&document.getElementById('ytPanel').classList.contains('on')===false?'block':'none';

    renderer.render(scene,camera);
  }
  requestAnimationFrame(animate);

  window.addEventListener('resize',()=>{
    camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth,window.innerHeight);
  });
  } catch(e) {
    const ld=document.getElementById('ld');
    ld.style.opacity='1'; ld.classList.remove('out');
    ld.innerHTML='<div style="color:#ff88cc;font-family:monospace;font-size:11px;padding:20px;text-align:center;line-height:1.8">ERROR:<br>'+e.message+'<br><br>'+e.stack.split('\n').slice(0,3).join('<br>')+'</div>';
  }
}
</script>
</body>
</html>
